// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../isolated_channels_demo/channels.dart';
import 'bridge.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Initializes the isolated channels demo runtime and installs the duplex handler.
Future<void> initIsolatedChannelsDemo() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeInitIsolatedChannelsDemo();

/// Emits a notification from Rust to Dart over the demo event channel.
Future<void> emitCounterDemoNotification({required String message}) => RustLib
    .instance
    .api
    .crateApiIsolatedChannelsBridgeEmitCounterDemoNotification(
      message: message,
    );

/// Streams demo events (Rust → Dart).
Stream<CounterDemoEvent> counterDemoEventsStream() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeCounterDemoEventsStream();

/// Streams callback requests (Rust → Dart) for the demo dialog service.
Stream<CounterDemoDialogPendingRequest> counterDemoDialogRequestsStream() =>
    RustLib.instance.api
        .crateApiIsolatedChannelsBridgeCounterDemoDialogRequestsStream();

/// Sends a callback response (Dart → Rust) for the demo dialog service.
Future<void> counterDemoDialogRespond({
  required BigInt id,
  required CounterDemoDialogResponse response,
}) =>
    RustLib.instance.api.crateApiIsolatedChannelsBridgeCounterDemoDialogRespond(
      id: id,
      response: response,
    );

/// Requests confirmation from Dart and returns the typed response payload.
Future<bool> counterDemoDialogConfirm({required String title}) => RustLib
    .instance
    .api
    .crateApiIsolatedChannelsBridgeCounterDemoDialogConfirm(title: title);

/// Requests confirmation from Dart using flutter_rust_bridge's direct Rust → Dart callback support.
Future<bool> counterDemoDialogConfirmViaFrbCallback({
  required String title,
  required FutureOr<bool> Function(String) dartConfirm,
}) => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeCounterDemoDialogConfirmViaFrbCallback(
      title: title,
      dartConfirm: dartConfirm,
    );

/// Streams duplex outgoing messages (Rust → Dart).
Stream<CounterDemoOut> counterDemoDuplexOutgoingStream() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeCounterDemoDuplexOutgoingStream();

/// Sends a duplex outgoing message from Rust to Dart.
Future<void> counterDemoDuplexSend({required String text}) => RustLib
    .instance
    .api
    .crateApiIsolatedChannelsBridgeCounterDemoDuplexSend(text: text);

/// Delivers a duplex incoming message from Dart to Rust.
Future<void> counterDemoDuplexIncoming({required CounterDemoIn event}) =>
    RustLib.instance.api
        .crateApiIsolatedChannelsBridgeCounterDemoDuplexIncoming(event: event);

/// Returns the last duplex incoming message text observed by Rust.
Future<String?> counterDemoLastIncomingText() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeCounterDemoLastIncomingText();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< OxideChannelError>>
abstract class OxideChannelError implements RustOpaqueInterface {}

/// A callback request envelope exposed to Dart for the demo dialog service.
///
/// Why this wrapper exists:
/// - The isolated-channels callback macro generates an internal request envelope
///   type whose name begins with underscores.
/// - Dart treats leading-underscore identifiers as library-private, so those
///   generated types cannot be imported and used from other generated files.
/// - Exposing this stable, public wrapper keeps the demo bindings usable.
class CounterDemoDialogPendingRequest {
  /// Request identifier that must be echoed back when responding.
  final BigInt id;

  /// Typed request payload.
  final CounterDemoDialogRequest request;

  const CounterDemoDialogPendingRequest({
    required this.id,
    required this.request,
  });

  @override
  int get hashCode => id.hashCode ^ request.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CounterDemoDialogPendingRequest &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          request == other.request;
}
