// Generated by oxide_generator. Do not edit.

import 'dart:async';
import 'dart:convert';

import 'package:flutter/widgets.dart';
import 'package:oxide_runtime/oxide_runtime.dart';

import 'route_builders.g.dart';
import '../routes/route_kind.g.dart';
import '../routes/route_models.g.dart';

import '../../src/rust/api/navigation_bridge.dart' as rust;

final GlobalKey<NavigatorState> oxideNavigatorKey = GlobalKey<NavigatorState>();

final NavigatorNavigationHandler<OxideRoute, RouteKind> oxideNavigationHandler =
    NavigatorNavigationHandler<OxideRoute, RouteKind>(
  navigatorKey: oxideNavigatorKey,
  kindOf: (r) => r.kind,
  routeBuilders: oxideRouteBuilders,
);

OxideNavigationCommand<OxideRoute, RouteKind>? _decodeOxideNavCommand(String json) {
  final obj = jsonDecode(json);
  if (obj is! Map<String, dynamic> || obj.length != 1) return null;
  final entry = obj.entries.first;

  switch (entry.key) {
    case 'Push':
      final payload = entry.value;
      if (payload is! Map<String, dynamic>) return null;
      final routeObj = payload['route'];
      if (routeObj is! Map<String, dynamic>) return null;
      final kind = routeObj['kind'];
      final routePayload = routeObj['payload'];
      if (kind is! String || routePayload is! Map<String, dynamic>) return null;
      final ticket = payload['ticket'] as String?;

      final route = switch (kind) {
        'Home' => HomeRoute.fromJson(routePayload),
        'Splash' => SplashRoute.fromJson(routePayload),
        'UserDetail' => UserDetailRoute.fromJson(routePayload),
        _ => null,
      };
      if (route == null) return null;
      return OxideNavigationCommand.push(route: route, ticket: ticket);
    case 'Pop':
      final payload = entry.value;
      if (payload is! Map<String, dynamic>) return null;
      return OxideNavigationCommand.pop(result: payload['result']);
    case 'PopUntil':
      final payload = entry.value;
      if (payload is! Map<String, dynamic>) return null;
      final kind = payload['kind'];
      if (kind is! String) return null;
      final routeKind = switch (kind) {
        'Home' => RouteKind.home,
        'Splash' => RouteKind.splash,
        'UserDetail' => RouteKind.userDetail,
        _ => null,
      };
      if (routeKind == null) return null;
      return OxideNavigationCommand.popUntil(kind: routeKind);
    case 'Reset':
      final payload = entry.value;
      if (payload is! Map<String, dynamic>) return null;
      final routes = payload['routes'];
      if (routes is! List) return null;
      final decoded = <OxideRoute>[];
      for (final r in routes) {
        if (r is! Map<String, dynamic>) continue;
        final kind = r['kind'];
        final routePayload = r['payload'];
        if (kind is! String || routePayload is! Map<String, dynamic>) continue;
        final route = switch (kind) {
          'Home' => HomeRoute.fromJson(routePayload),
          'Splash' => SplashRoute.fromJson(routePayload),
          'UserDetail' => UserDetailRoute.fromJson(routePayload),
          _ => null,
        };
        if (route != null) decoded.add(route);
      }
      return OxideNavigationCommand.reset(routes: decoded);
  }

  return null;
}

final OxideNavigationRuntime<OxideRoute, RouteKind> oxideNavigationRuntime =
    OxideNavigationRuntime<OxideRoute, RouteKind>(
  commands: rust
      .oxideNavCommandsStream()
      .map(_decodeOxideNavCommand)
      .where((c) => c != null)
      .cast<OxideNavigationCommand<OxideRoute, RouteKind>>(),
  handler: oxideNavigationHandler,
  emitResult: (ticket, result) =>
      rust.oxideNavEmitResult(ticket: ticket, resultJson: jsonEncode(result)),
  setCurrentRoute: (route) =>
      rust.oxideNavSetCurrentRoute(kind: route.kind.asStr, payloadJson: jsonEncode(route.toJson())),
);

void oxideNavStart() {
  oxideNavigationRuntime.start();
}

Future<void> oxideNavStop() => oxideNavigationRuntime.stop();
