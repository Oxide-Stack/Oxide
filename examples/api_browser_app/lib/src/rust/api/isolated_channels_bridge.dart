// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../isolated_channels_demo/channels.dart';
import 'bridge.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Initializes the isolated channels demo runtime and installs the duplex handler.
Future<void> initIsolatedChannelsDemo() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeInitIsolatedChannelsDemo();

/// Emits a notification from Rust to Dart over the demo event channel.
Future<void> emitApiBrowserDemoNotification({required String message}) =>
    RustLib.instance.api
        .crateApiIsolatedChannelsBridgeEmitApiBrowserDemoNotification(
          message: message,
        );

/// Streams demo events (Rust → Dart).
Stream<ApiBrowserDemoEvent> apiBrowserDemoEventsStream() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoEventsStream();

/// Streams callback requests (Rust → Dart) for the demo dialog service.
Stream<ApiBrowserDemoDialogPendingRequest>
apiBrowserDemoDialogRequestsStream() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoDialogRequestsStream();

/// Sends a callback response (Dart → Rust) for the demo dialog service.
Future<void> apiBrowserDemoDialogRespond({
  required BigInt id,
  required ApiBrowserDemoDialogResponse response,
}) => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoDialogRespond(
      id: id,
      response: response,
    );

/// Requests confirmation from Dart and returns the typed response payload.
Future<bool> apiBrowserDemoDialogConfirm({required String title}) => RustLib
    .instance
    .api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoDialogConfirm(title: title);

/// Requests confirmation from Dart using flutter_rust_bridge's direct Rust → Dart callback support.
Future<bool> apiBrowserDemoDialogConfirmViaFrbCallback({
  required String title,
  required FutureOr<bool> Function(String) dartConfirm,
}) => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoDialogConfirmViaFrbCallback(
      title: title,
      dartConfirm: dartConfirm,
    );

/// Streams duplex outgoing messages (Rust → Dart).
Stream<ApiBrowserDemoOut> apiBrowserDemoDuplexOutgoingStream() => RustLib
    .instance
    .api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoDuplexOutgoingStream();

/// Sends a duplex outgoing message from Rust to Dart.
Future<void> apiBrowserDemoDuplexSend({required String text}) => RustLib
    .instance
    .api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoDuplexSend(text: text);

/// Delivers a duplex incoming message from Dart to Rust.
Future<void> apiBrowserDemoDuplexIncoming({required ApiBrowserDemoIn event}) =>
    RustLib.instance.api
        .crateApiIsolatedChannelsBridgeApiBrowserDemoDuplexIncoming(
          event: event,
        );

/// Returns the last duplex incoming message text observed by Rust.
Future<String?> apiBrowserDemoLastIncomingText() => RustLib.instance.api
    .crateApiIsolatedChannelsBridgeApiBrowserDemoLastIncomingText();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< OxideChannelError>>
abstract class OxideChannelError implements RustOpaqueInterface {}

/// A callback request envelope exposed to Dart for the demo dialog service.
///
/// Why this wrapper exists:
/// - The isolated-channels callback macro generates an internal request envelope
///   type whose name begins with underscores.
/// - Dart treats leading-underscore identifiers as library-private, so those
///   generated types cannot be imported and used from other generated files.
/// - Exposing this stable, public wrapper keeps the demo bindings usable.
class ApiBrowserDemoDialogPendingRequest {
  /// Request identifier that must be echoed back when responding.
  final BigInt id;

  /// Typed request payload.
  final ApiBrowserDemoDialogRequest request;

  const ApiBrowserDemoDialogPendingRequest({
    required this.id,
    required this.request,
  });

  @override
  int get hashCode => id.hashCode ^ request.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApiBrowserDemoDialogPendingRequest &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          request == other.request;
}
